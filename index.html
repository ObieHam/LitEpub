<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebToEpub PWA</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .container {
            background: white;
            border-radius: 16px;
            padding: 40px;
            max-width: 700px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        h1 {
            color: #6200ea;
            margin-bottom: 10px;
            font-size: 2em;
        }
        
        p {
            color: #666;
            margin-bottom: 20px;
            line-height: 1.6;
        }
        
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }
        
        .tab {
            padding: 12px 24px;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 15px;
            font-weight: 600;
            color: #666;
            transition: all 0.3s;
        }
        
        .tab:hover {
            color: #6200ea;
        }
        
        .tab.active {
            color: #6200ea;
            border-bottom-color: #6200ea;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        textarea {
            width: 100%;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            font-family: monospace;
            resize: vertical;
            min-height: 200px;
            margin-bottom: 15px;
            transition: border-color 0.3s;
        }
        
        textarea:focus {
            outline: none;
            border-color: #6200ea;
        }
        
        input[type="text"] {
            width: 100%;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            margin-bottom: 20px;
            transition: border-color 0.3s;
        }
        
        input[type="text"]:focus {
            outline: none;
            border-color: #6200ea;
        }
        
        button {
            width: 100%;
            padding: 15px;
            background: #6200ea;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #5000d0;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        #status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            display: none;
        }
        
        #status.show {
            display: block;
        }
        
        #status.loading {
            background: #e3f2fd;
            color: #1976d2;
            border: 1px solid #90caf9;
        }
        
        #status.success {
            background: #e8f5e9;
            color: #388e3c;
            border: 1px solid #81c784;
        }
        
        #status.error {
            background: #ffebee;
            color: #d32f2f;
            border: 1px solid #ef5350;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }
        
        .hint {
            font-size: 12px;
            color: #999;
            margin-top: -10px;
            margin-bottom: 15px;
        }
        
        .info-box {
            background: #e8eaf6;
            border-left: 4px solid #6200ea;
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 20px;
            font-size: 14px;
            color: #333;
        }
        
        code {
            background: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 13px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>WebToEpub</h1>
        <p>Download Literotica stories as EPUB files</p>
        
        <div class="tabs">
            <button class="tab active" data-tab="chapters">Individual Chapters</button>
            <button class="tab" data-tab="series">Series URL</button>
        </div>
        
        <div id="chapters-tab" class="tab-content active">
            <div class="info-box">
                <strong>ðŸ“– Individual Chapters Mode</strong><br>
                Paste individual story URLs (one per line) to combine them into one EPUB.
            </div>
            
            <label for="chaptersInput">Chapter URLs (one per line)</label>
            <textarea id="chaptersInput" placeholder="https://www.literotica.com/s/story-ch-01
https://www.literotica.com/s/story-ch-02
https://www.literotica.com/s/story-ch-03"></textarea>
            <p class="hint">Example: https://www.literotica.com/s/story-name</p>
            
            <label for="bookTitle1">Book Title (optional)</label>
            <input type="text" id="bookTitle1" placeholder="Leave empty to use first chapter's title">
            
            <button id="convertChaptersBtn">Download EPUB</button>
        </div>
        
        <div id="series-tab" class="tab-content">
            <div class="info-box">
                <strong>ðŸ“š Series Mode</strong><br>
                Paste a series URL and all chapters will be automatically extracted and combined.
            </div>
            
            <label for="seriesInput">Series URL</label>
            <input type="text" id="seriesInput" placeholder="https://www.literotica.com/series/se/...">
            <p class="hint">Example: https://www.literotica.com/series/se/series-name</p>
            
            <label for="bookTitle2">Book Title (optional)</label>
            <input type="text" id="bookTitle2" placeholder="Leave empty to use series title">
            
            <button id="convertSeriesBtn">Download EPUB</button>
        </div>
        
        <div id="status"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    
    <script>
        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const tabName = tab.dataset.tab;
                
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                tab.classList.add('active');
                document.getElementById(`${tabName}-tab`).classList.add('active');
            });
        });

        const status = document.getElementById('status');

        function showStatus(message, type) {
            status.textContent = message;
            status.className = `show ${type}`;
        }

        function sanitizeFilename(name) {
            return name.replace(/[^a-z0-9]/gi, '_').toLowerCase();
        }

        async function fetchChapter(url) {
            const response = await fetch(`https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`);
            if (!response.ok) throw new Error(`Failed to fetch: ${url}`);
            
            const html = await response.text();
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            
            // Get title
            let title = doc.querySelector('h1')?.textContent?.trim();
            if (!title || title === '') {
                title = doc.querySelector('.j_bm h1')?.textContent?.trim();
            }
            if (!title || title === '') {
                title = doc.querySelector('meta[property="og:title"]')?.getAttribute('content')?.trim();
            }
            title = title || 'Untitled';
            
            // Get author
            let author = doc.querySelector('.y_eU')?.textContent?.trim();
            if (!author || author === '') {
                author = doc.querySelector('.x_bj a')?.textContent?.trim();
            }
            if (!author || author === '') {
                author = doc.querySelector('meta[name="author"]')?.getAttribute('content')?.trim();
            }
            author = author || 'Unknown';
            
            // Get content
            let content = '';
            let contentDiv = doc.querySelector('.aa_ht');
            if (!contentDiv) {
                contentDiv = doc.querySelector('div.panel article');
            }
            if (!contentDiv) {
                contentDiv = doc.querySelector('.b-story-body-x');
            }
            
            if (contentDiv) {
                const unwanted = contentDiv.querySelectorAll('script, .l_bJ, .t_bT, .ad, .advertisement');
                unwanted.forEach(el => el.remove());
                
                const paragraphs = contentDiv.querySelectorAll('p');
                if (paragraphs.length > 0) {
                    paragraphs.forEach(p => {
                        const text = p.innerHTML.trim();
                        if (text && text.length > 0) {
                            content += `<p>${text}</p>\n`;
                        }
                    });
                } else {
                    const textContent = contentDiv.textContent.trim();
                    if (textContent) {
                        const lines = textContent.split('\n\n');
                        lines.forEach(line => {
                            const trimmed = line.trim();
                            if (trimmed) {
                                content += `<p>${trimmed}</p>\n`;
                            }
                        });
                    }
                }
            }
            
            if (!content || content.trim() === '') {
                throw new Error(`Could not extract story content from: ${url}`);
            }
            
            return { title, author, content };
        }

        async function fetchSeriesChapters(seriesUrl) {
            const response = await fetch(`https://api.allorigins.win/raw?url=${encodeURIComponent(seriesUrl)}`);
            if (!response.ok) throw new Error(`Failed to fetch series page: ${seriesUrl}`);
            
            const html = await response.text();
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            
            // Get series title
            let seriesTitle = doc.querySelector('h1')?.textContent?.trim();
            if (!seriesTitle) {
                seriesTitle = doc.querySelector('.ser_ttl')?.textContent?.trim();
            }
            if (!seriesTitle) {
                seriesTitle = doc.querySelector('meta[property="og:title"]')?.getAttribute('content')?.trim();
            }
            seriesTitle = seriesTitle || 'Series';
            
            // Find all chapter links
            const chapterLinks = [];
            const links = doc.querySelectorAll('a[href*="/s/"]');
            
            links.forEach(link => {
                const href = link.href || link.getAttribute('href');
                if (href && href.includes('/s/') && !href.includes('/series/')) {
                    // Make sure it's a full URL
                    const fullUrl = href.startsWith('http') ? href : `https://www.literotica.com${href}`;
                    
                    // Avoid duplicates
                    if (!chapterLinks.includes(fullUrl)) {
                        chapterLinks.push(fullUrl);
                    }
                }
            });
            
            if (chapterLinks.length === 0) {
                throw new Error('No chapters found in series. Make sure this is a valid series URL.');
            }
            
            return { seriesTitle, chapterLinks };
        }

        function generateEpub(chapters, bookTitle, author) {
            const zip = new JSZip();
            
            zip.file('mimetype', 'application/epub+zip', {compression: 'STORE'});
            
            zip.file('META-INF/container.xml', `<?xml version="1.0"?>
<container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container">
  <rootfiles>
    <rootfile full-path="OEBPS/content.opf" media-type="application/oebps-package+xml"/>
  </rootfiles>
</container>`);
            
            let manifestItems = '';
            let spineItems = '';
            let tocItems = '';
            
            chapters.forEach((chapter, index) => {
                const chapterId = `chapter${index + 1}`;
                const filename = `${chapterId}.xhtml`;
                
                zip.file(`OEBPS/${filename}`, `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>${chapter.title}</title>
    <link rel="stylesheet" type="text/css" href="style.css"/>
</head>
<body>
    <h1>${chapter.title}</h1>
    ${chapter.content}
</body>
</html>`);
                
                manifestItems += `    <item id="${chapterId}" href="${filename}" media-type="application/xhtml+xml"/>\n`;
                spineItems += `    <itemref idref="${chapterId}"/>\n`;
                tocItems += `    <navPoint id="navPoint-${index + 1}" playOrder="${index + 1}">
      <navLabel><text>${chapter.title}</text></navLabel>
      <content src="${filename}"/>
    </navPoint>\n`;
            });
            
            zip.file('OEBPS/content.opf', `<?xml version="1.0" encoding="UTF-8"?>
<package xmlns="http://www.idpf.org/2007/opf" unique-identifier="BookId" version="2.0">
  <metadata xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:opf="http://www.idpf.org/2007/opf">
    <dc:title>${bookTitle}</dc:title>
    <dc:creator>${author}</dc:creator>
    <dc:language>en</dc:language>
    <dc:identifier id="BookId">urn:uuid:${Date.now()}</dc:identifier>
  </metadata>
  <manifest>
${manifestItems}    <item id="ncx" href="toc.ncx" media-type="application/x-dtbncx+xml"/>
    <item id="style" href="style.css" media-type="text/css"/>
  </manifest>
  <spine toc="ncx">
${spineItems}  </spine>
</package>`);
            
            zip.file('OEBPS/toc.ncx', `<?xml version="1.0" encoding="UTF-8"?>
<ncx xmlns="http://www.daisy.org/z3986/2005/ncx/" version="2005-1">
  <head>
    <meta name="dtb:uid" content="urn:uuid:${Date.now()}"/>
    <meta name="dtb:depth" content="1"/>
    <meta name="dtb:totalPageCount" content="0"/>
    <meta name="dtb:maxPageNumber" content="0"/>
  </head>
  <docTitle><text>${bookTitle}</text></docTitle>
  <navMap>
${tocItems}  </navMap>
</ncx>`);
            
            zip.file('OEBPS/style.css', `body {
    font-family: Georgia, serif;
    line-height: 1.6;
    margin: 2em;
}
h1 {
    text-align: center;
    margin-bottom: 2em;
}
p {
    text-indent: 1.5em;
    margin: 0;
}
p:first-of-type {
    text-indent: 0;
}`);
            
            return zip;
        }

        // Individual chapters handler
        document.getElementById('convertChaptersBtn').addEventListener('click', async () => {
            const input = document.getElementById('chaptersInput');
            const titleInput = document.getElementById('bookTitle1');
            const btn = document.getElementById('convertChaptersBtn');
            
            const urls = input.value.trim().split('\n').filter(line => line.trim());
            
            if (urls.length === 0) {
                showStatus('Please enter at least one URL', 'error');
                return;
            }
            
            const invalidUrls = urls.filter(url => !url.includes('literotica.com'));
            if (invalidUrls.length > 0) {
                showStatus('All URLs must be from literotica.com', 'error');
                return;
            }
            
            btn.disabled = true;
            showStatus('Fetching chapters...', 'loading');
            
            try {
                const chapters = [];
                let firstAuthor = '';
                
                for (let i = 0; i < urls.length; i++) {
                    showStatus(`Fetching chapter ${i + 1} of ${urls.length}...`, 'loading');
                    const chapter = await fetchChapter(urls[i].trim());
                    chapters.push(chapter);
                    
                    if (i === 0) firstAuthor = chapter.author;
                }
                
                showStatus('Generating EPUB...', 'loading');
                
                const bookTitle = titleInput.value.trim() || chapters[0].title;
                const zip = generateEpub(chapters, bookTitle, firstAuthor);
                
                const blob = await zip.generateAsync({type: 'blob'});
                saveAs(blob, `${sanitizeFilename(bookTitle)}.epub`);
                
                showStatus(`Successfully downloaded ${chapters.length} chapter(s)!`, 'success');
            } catch (error) {
                showStatus(`Error: ${error.message}`, 'error');
                console.error(error);
            } finally {
                btn.disabled = false;
            }
        });

        // Series handler
        document.getElementById('convertSeriesBtn').addEventListener('click', async () => {
            const input = document.getElementById('seriesInput');
            const titleInput = document.getElementById('bookTitle2');
            const btn = document.getElementById('convertSeriesBtn');
            
            const seriesUrl = input.value.trim();
            
            if (!seriesUrl) {
                showStatus('Please enter a series URL', 'error');
                return;
            }
            
            if (!seriesUrl.includes('literotica.com')) {
                showStatus('URL must be from literotica.com', 'error');
                return;
            }
            
            btn.disabled = true;
            showStatus('Fetching series information...', 'loading');
            
            try {
                const { seriesTitle, chapterLinks } = await fetchSeriesChapters(seriesUrl);
                
                showStatus(`Found ${chapterLinks.length} chapters. Downloading...`, 'loading');
                
                const chapters = [];
                let firstAuthor = '';
                
                for (let i = 0; i < chapterLinks.length; i++) {
                    showStatus(`Fetching chapter ${i + 1} of ${chapterLinks.length}...`, 'loading');
                    const chapter = await fetchChapter(chapterLinks[i]);
                    chapters.push(chapter);
                    
                    if (i === 0) firstAuthor = chapter.author;
                }
                
                showStatus('Generating EPUB...', 'loading');
                
                const bookTitle = titleInput.value.trim() || seriesTitle;
                const zip = generateEpub(chapters, bookTitle, firstAuthor);
                
                const blob = await zip.generateAsync({type: 'blob'});
                saveAs(blob, `${sanitizeFilename(bookTitle)}.epub`);
                
                showStatus(`Successfully downloaded ${chapters.length} chapters from series!`, 'success');
            } catch (error) {
                showStatus(`Error: ${error.message}`, 'error');
                console.error(error);
            } finally {
                btn.disabled = false;
            }
        });
    </script>
</body>
</html>
